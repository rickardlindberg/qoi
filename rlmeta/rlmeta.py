SUPPORT = 'class VM:\n\n    def __init__(self, code, rules):\n        self.code = code\n        self.rules = rules\n\n    def run(self, start_rule, stream):\n        self.action = SemanticAction(None)\n        self.pc = self.rules[start_rule]\n        self.call_backtrack_stack = []\n        self.stream, self.stream_rest = (stream, None)\n        self.pos, self.pos_rest = (0, tuple())\n        self.scope, self.scope_rest = (None, None)\n        self.latest_fail_message, self.latest_fail_pos = (None, tuple())\n        self.memo = {}\n        while True:\n            result = self.pop_arg()(self)\n            if result:\n                return result\n\n    def pop_arg(self):\n        code = self.code[self.pc]\n        self.pc += 1\n        return code\n\ndef PUSH_SCOPE(vm):\n    vm.scope_rest = (vm.scope, vm.scope_rest)\n    vm.scope = {}\n\ndef POP_SCOPE(vm):\n    vm.scope, vm.scope_rest = vm.scope_rest\n\ndef BACKTRACK(vm):\n    vm.call_backtrack_stack.append((\n        vm.pop_arg(), vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest\n    ))\n\ndef COMMIT(vm):\n    vm.call_backtrack_stack.pop()\n    vm.pc = vm.pop_arg()\n\ndef CALL(vm):\n    CALL_(vm, vm.pop_arg())\n\ndef CALL_(vm, pc):\n    key = (pc, vm.pos_rest+(vm.pos,))\n    if key in vm.memo:\n        if vm.memo[key][0] is None:\n            FAIL_(vm, vm.memo[key][1])\n        else:\n            vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest = vm.memo[key]\n    else:\n        vm.call_backtrack_stack.append((vm.pc, key))\n        vm.pc = pc\n\ndef RETURN(vm):\n    if not vm.call_backtrack_stack:\n        return vm.action\n    vm.pc, key = vm.call_backtrack_stack.pop()\n    vm.memo[key] = (vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest)\n\ndef MATCH(vm):\n    object_description = vm.pop_arg()\n    fn = vm.pop_arg()\n    MATCH_(vm, fn, ("expected {}", object_description))\n\ndef MATCH_BINARY(vm):\n    pattern = vm.pop_arg()\n    if MATCH_(vm, lambda x: x & pattern["mask"] == pattern["value"], ("expected binary",)):\n        byte = vm.stream[vm.pos-1]\n        for key, value in pattern["variables"].items():\n            vm.scope[key] = SemanticAction(\n                (byte & value["mask"]) >> value["shift"]\n            )\n\ndef MATCH_(vm, fn, message):\n    if vm.pos >= len(vm.stream) or not fn(vm.stream[vm.pos]):\n        FAIL_(vm, message)\n    else:\n        vm.action = SemanticAction(vm.stream[vm.pos])\n        vm.pos += 1\n        return True\n\ndef MATCH_CALL_RULE(vm):\n    if MATCH_(vm, lambda x: x in vm.rules, ("expected rule name",)):\n        CALL_(vm, vm.rules[vm.action.value])\n\ndef LIST_START(vm):\n    vm.scope_rest = (vm.scope, vm.scope_rest)\n    vm.scope = []\n\ndef LIST_APPEND(vm):\n    vm.scope.append(vm.action)\n\ndef LIST_END(vm):\n    vm.action = SemanticAction(vm.scope, lambda self: [x.eval(self.runtime) for x in self.value])\n    vm.scope, vm.scope_rest = vm.scope_rest\n\ndef BIND(vm):\n    vm.scope[vm.pop_arg()] = vm.action\n\ndef ACTION(vm):\n    vm.action = SemanticAction(vm.scope, vm.pop_arg())\n\ndef PUSH_STREAM(vm):\n    if vm.pos >= len(vm.stream) or not isinstance(vm.stream[vm.pos], list):\n        FAIL_(vm, ("expected list",))\n    else:\n        vm.stream_rest = (vm.stream, vm.stream_rest)\n        vm.pos_rest = vm.pos_rest + (vm.pos,)\n        vm.stream = vm.stream[vm.pos]\n        vm.pos = 0\n\ndef POP_STREAM(vm):\n    if vm.pos < len(vm.stream):\n        FAIL_(vm, ("expected end of list",))\n    else:\n        vm.stream, vm.stream_rest = vm.stream_rest\n        vm.pos, vm.pos_rest = vm.pos_rest[-1], vm.pos_rest[:-1]\n        vm.pos += 1\n\ndef FAIL(vm):\n    FAIL_(vm, (vm.pop_arg(),))\n\ndef FAIL_(vm, fail_message):\n    fail_pos = vm.pos_rest+(vm.pos,)\n    if fail_pos >= vm.latest_fail_pos:\n        vm.latest_fail_message = fail_message\n        vm.latest_fail_pos = fail_pos\n    call_backtrack_entry = tuple()\n    while vm.call_backtrack_stack:\n        call_backtrack_entry = vm.call_backtrack_stack.pop()\n        if len(call_backtrack_entry) == 7:\n            break\n        else:\n            vm.memo[call_backtrack_entry[1]] = (None, fail_message)\n    if len(call_backtrack_entry) != 7:\n        raise MatchError(\n            vm.latest_fail_message[0].format(*vm.latest_fail_message[1:]),\n            vm.latest_fail_pos[-1],\n            vm.stream\n        )\n    (vm.pc, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest) = call_backtrack_entry\n\nclass SemanticAction(object):\n\n    def __init__(self, value, fn=lambda self: self.value):\n        self.value = value\n        self.fn = fn\n\n    def eval(self, runtime):\n        self.runtime = runtime\n        return self.fn(self)\n\n    def bind(self, name, value, continuation):\n        self.runtime = self.runtime.set(name, value)\n        return continuation()\n\n    def lookup(self, name):\n        if name in self.value:\n            return self.value[name].eval(self.runtime)\n        else:\n            return self.runtime[name]\n\nclass MatchError(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\nclass Grammar(object):\n\n    def run(self, rule, stream, runtime={}):\n        return Runtime(self, dict(runtime, **{\n            "label": Counter(),\n            "indentprefix": "    ",\n            "list": list,\n            "dict": dict,\n            "add": lambda x, y: x.append(y),\n            "get": lambda x, y: x[y],\n            "set": lambda x, y, z: x.__setitem__(y, z),\n            "len": len,\n            "int": int,\n            "compilebin": compilebin,\n            "repr": repr,\n            "join": join,\n        })).run(rule, stream)\n\nclass Runtime(dict):\n\n    def __init__(self, grammar, values):\n        dict.__init__(self, dict(values, run=self.run))\n        self.grammar = grammar\n\n    def set(self, key, value):\n        return Runtime(self.grammar, dict(self, **{key: value}))\n\n    def run(self, rule, stream):\n        return VM(self.grammar.code, self.grammar.rules).run(rule, stream).eval(self)\n\nclass Counter(object):\n\n    def __init__(self):\n        self.value = 0\n\n    def __call__(self):\n        result = self.value\n        self.value += 1\n        return result\n\ndef splice(depth, item):\n    if depth == 0:\n        return [item]\n    else:\n        return concat([splice(depth-1, subitem) for subitem in item])\n\ndef concat(lists):\n    return [x for xs in lists for x in xs]\n\ndef join(items, delimiter=""):\n    return delimiter.join(\n        join(item, delimiter) if isinstance(item, list) else str(item)\n        for item in items\n    )\n\ndef indent(text, prefix="    "):\n    return "".join(prefix+line for line in text.splitlines(True))\n\ndef compile_chain(grammars, source):\n    import sys\n    import pprint\n    for grammar, rule in grammars:\n        try:\n            source = grammar().run(rule, source)\n        except MatchError as e:\n            MARKER = "\\033[0;31m<ERROR POSITION>\\033[0m"\n            if isinstance(e.stream, str):\n                stream_string = e.stream[:e.pos] + MARKER + e.stream[e.pos:]\n            else:\n                stream_string = pprint.pformat(e.stream)\n            sys.exit("ERROR: {}\\nPOSITION: {}\\nSTREAM:\\n{}".format(\n                e.message,\n                e.pos,\n                indent(stream_string)\n            ))\n    return source\n\ndef compilebin(pattern):\n    result = {\n        "mask": 0,\n        "value": 0,\n        "variables": {},\n    }\n    last_char = None\n    for index, char in enumerate(reversed(pattern)):\n        if char in "01":\n            result["mask"] |= (1 << index)\n            if char == "1":\n                result["value"] |= (1 << index)\n        else:\n            if char != last_char:\n                result["variables"][char] = {\n                    "mask": 1 << index,\n                    "shift": index,\n                }\n                last_char = char\n            else:\n                result["variables"][char]["mask"] |= (1 << index)\n    return result\n'
class VM:

    def __init__(self, code, rules):
        self.code = code
        self.rules = rules

    def run(self, start_rule, stream):
        self.action = SemanticAction(None)
        self.pc = self.rules[start_rule]
        self.call_backtrack_stack = []
        self.stream, self.stream_rest = (stream, None)
        self.pos, self.pos_rest = (0, tuple())
        self.scope, self.scope_rest = (None, None)
        self.latest_fail_message, self.latest_fail_pos = (None, tuple())
        self.memo = {}
        while True:
            result = self.pop_arg()(self)
            if result:
                return result

    def pop_arg(self):
        code = self.code[self.pc]
        self.pc += 1
        return code

def PUSH_SCOPE(vm):
    vm.scope_rest = (vm.scope, vm.scope_rest)
    vm.scope = {}

def POP_SCOPE(vm):
    vm.scope, vm.scope_rest = vm.scope_rest

def BACKTRACK(vm):
    vm.call_backtrack_stack.append((
        vm.pop_arg(), vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest
    ))

def COMMIT(vm):
    vm.call_backtrack_stack.pop()
    vm.pc = vm.pop_arg()

def CALL(vm):
    CALL_(vm, vm.pop_arg())

def CALL_(vm, pc):
    key = (pc, vm.pos_rest+(vm.pos,))
    if key in vm.memo:
        if vm.memo[key][0] is None:
            FAIL_(vm, vm.memo[key][1])
        else:
            vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest = vm.memo[key]
    else:
        vm.call_backtrack_stack.append((vm.pc, key))
        vm.pc = pc

def RETURN(vm):
    if not vm.call_backtrack_stack:
        return vm.action
    vm.pc, key = vm.call_backtrack_stack.pop()
    vm.memo[key] = (vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest)

def MATCH(vm):
    object_description = vm.pop_arg()
    fn = vm.pop_arg()
    MATCH_(vm, fn, ("expected {}", object_description))

def MATCH_BINARY(vm):
    pattern = vm.pop_arg()
    if MATCH_(vm, lambda x: x & pattern["mask"] == pattern["value"], ("expected binary",)):
        byte = vm.stream[vm.pos-1]
        for key, value in pattern["variables"].items():
            vm.scope[key] = SemanticAction(
                (byte & value["mask"]) >> value["shift"]
            )

def MATCH_(vm, fn, message):
    if vm.pos >= len(vm.stream) or not fn(vm.stream[vm.pos]):
        FAIL_(vm, message)
    else:
        vm.action = SemanticAction(vm.stream[vm.pos])
        vm.pos += 1
        return True

def MATCH_CALL_RULE(vm):
    if MATCH_(vm, lambda x: x in vm.rules, ("expected rule name",)):
        CALL_(vm, vm.rules[vm.action.value])

def LIST_START(vm):
    vm.scope_rest = (vm.scope, vm.scope_rest)
    vm.scope = []

def LIST_APPEND(vm):
    vm.scope.append(vm.action)

def LIST_END(vm):
    vm.action = SemanticAction(vm.scope, lambda self: [x.eval(self.runtime) for x in self.value])
    vm.scope, vm.scope_rest = vm.scope_rest

def BIND(vm):
    vm.scope[vm.pop_arg()] = vm.action

def ACTION(vm):
    vm.action = SemanticAction(vm.scope, vm.pop_arg())

def PUSH_STREAM(vm):
    if vm.pos >= len(vm.stream) or not isinstance(vm.stream[vm.pos], list):
        FAIL_(vm, ("expected list",))
    else:
        vm.stream_rest = (vm.stream, vm.stream_rest)
        vm.pos_rest = vm.pos_rest + (vm.pos,)
        vm.stream = vm.stream[vm.pos]
        vm.pos = 0

def POP_STREAM(vm):
    if vm.pos < len(vm.stream):
        FAIL_(vm, ("expected end of list",))
    else:
        vm.stream, vm.stream_rest = vm.stream_rest
        vm.pos, vm.pos_rest = vm.pos_rest[-1], vm.pos_rest[:-1]
        vm.pos += 1

def FAIL(vm):
    FAIL_(vm, (vm.pop_arg(),))

def FAIL_(vm, fail_message):
    fail_pos = vm.pos_rest+(vm.pos,)
    if fail_pos >= vm.latest_fail_pos:
        vm.latest_fail_message = fail_message
        vm.latest_fail_pos = fail_pos
    call_backtrack_entry = tuple()
    while vm.call_backtrack_stack:
        call_backtrack_entry = vm.call_backtrack_stack.pop()
        if len(call_backtrack_entry) == 7:
            break
        else:
            vm.memo[call_backtrack_entry[1]] = (None, fail_message)
    if len(call_backtrack_entry) != 7:
        raise MatchError(
            vm.latest_fail_message[0].format(*vm.latest_fail_message[1:]),
            vm.latest_fail_pos[-1],
            vm.stream
        )
    (vm.pc, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest) = call_backtrack_entry

class SemanticAction(object):

    def __init__(self, value, fn=lambda self: self.value):
        self.value = value
        self.fn = fn

    def eval(self, runtime):
        self.runtime = runtime
        return self.fn(self)

    def bind(self, name, value, continuation):
        self.runtime = self.runtime.set(name, value)
        return continuation()

    def lookup(self, name):
        if name in self.value:
            return self.value[name].eval(self.runtime)
        else:
            return self.runtime[name]

class MatchError(Exception):

    def __init__(self, message, pos, stream):
        Exception.__init__(self)
        self.message = message
        self.pos = pos
        self.stream = stream

class Grammar(object):

    def run(self, rule, stream, runtime={}):
        return Runtime(self, dict(runtime, **{
            "label": Counter(),
            "indentprefix": "    ",
            "list": list,
            "dict": dict,
            "add": lambda x, y: x.append(y),
            "get": lambda x, y: x[y],
            "set": lambda x, y, z: x.__setitem__(y, z),
            "len": len,
            "int": int,
            "compilebin": compilebin,
            "repr": repr,
            "join": join,
        })).run(rule, stream)

class Runtime(dict):

    def __init__(self, grammar, values):
        dict.__init__(self, dict(values, run=self.run))
        self.grammar = grammar

    def set(self, key, value):
        return Runtime(self.grammar, dict(self, **{key: value}))

    def run(self, rule, stream):
        return VM(self.grammar.code, self.grammar.rules).run(rule, stream).eval(self)

class Counter(object):

    def __init__(self):
        self.value = 0

    def __call__(self):
        result = self.value
        self.value += 1
        return result

def splice(depth, item):
    if depth == 0:
        return [item]
    else:
        return concat([splice(depth-1, subitem) for subitem in item])

def concat(lists):
    return [x for xs in lists for x in xs]

def join(items, delimiter=""):
    return delimiter.join(
        join(item, delimiter) if isinstance(item, list) else str(item)
        for item in items
    )

def indent(text, prefix="    "):
    return "".join(prefix+line for line in text.splitlines(True))

def compile_chain(grammars, source):
    import sys
    import pprint
    for grammar, rule in grammars:
        try:
            source = grammar().run(rule, source)
        except MatchError as e:
            MARKER = "\033[0;31m<ERROR POSITION>\033[0m"
            if isinstance(e.stream, str):
                stream_string = e.stream[:e.pos] + MARKER + e.stream[e.pos:]
            else:
                stream_string = pprint.pformat(e.stream)
            sys.exit("ERROR: {}\nPOSITION: {}\nSTREAM:\n{}".format(
                e.message,
                e.pos,
                indent(stream_string)
            ))
    return source

def compilebin(pattern):
    result = {
        "mask": 0,
        "value": 0,
        "variables": {},
    }
    last_char = None
    for index, char in enumerate(reversed(pattern)):
        if char in "01":
            result["mask"] |= (1 << index)
            if char == "1":
                result["value"] |= (1 << index)
        else:
            if char != last_char:
                result["variables"][char] = {
                    "mask": 1 << index,
                    "shift": index,
                }
                last_char = char
            else:
                result["variables"][char]["mask"] |= (1 << index)
    return result
class Parser(Grammar):
    rules = {
        'file': 0,
        'grammar': 31,
        'rule': 61,
        'choice': 79,
        'sequence': 117,
        'expr': 137,
        'expr1': 163,
        'expr2': 232,
        'matchChar': 439,
        'maybeAction': 448,
        'actionExpr': 465,
        'hostExpr': 525,
        'op': 710,
        'hostListItem': 757,
        'formatExpr': 780,
        'string': 814,
        'char': 847,
        'innerChar': 871,
        'escape': 888,
        'name': 929,
        'nameStart': 951,
        'nameChar': 966,
        'digit': 990,
        'hex': 996,
        'bin': 1011,
        'space': 1035
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        13,
        PUSH_SCOPE,
        CALL,
        1035,
        CALL,
        31,
        POP_SCOPE,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        CALL,
        1035,
        BACKTRACK,
        27,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        25,
        FAIL,
        'no match',
        ACTION,
        lambda self: self.lookup('xs'),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        929,
        BIND,
        'x',
        CALL,
        1035,
        MATCH,
        '{',
        lambda x: x == '{',
        LIST_START,
        BACKTRACK,
        49,
        CALL,
        61,
        LIST_APPEND,
        COMMIT,
        42,
        LIST_END,
        BIND,
        'ys',
        CALL,
        1035,
        MATCH,
        '}',
        lambda x: x == '}',
        ACTION,
        lambda self: concat([splice(0, 'Grammar'), splice(0, self.lookup('x')), splice(1, self.lookup('ys'))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        929,
        BIND,
        'x',
        CALL,
        1035,
        MATCH,
        '=',
        lambda x: x == '=',
        CALL,
        79,
        BIND,
        'y',
        ACTION,
        lambda self: concat([splice(0, 'Rule'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        BACKTRACK,
        91,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '|',
        lambda x: x == '|',
        POP_SCOPE,
        COMMIT,
        91,
        CALL,
        117,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        110,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '|',
        lambda x: x == '|',
        CALL,
        117,
        POP_SCOPE,
        LIST_APPEND,
        COMMIT,
        96,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: concat([splice(0, 'Or'), splice(0, self.lookup('x')), splice(1, self.lookup('xs'))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        126,
        CALL,
        137,
        LIST_APPEND,
        COMMIT,
        119,
        LIST_END,
        BIND,
        'xs',
        CALL,
        448,
        BIND,
        'ys',
        ACTION,
        lambda self: concat([splice(0, 'Scope'), splice(0, concat([splice(0, 'And'), splice(1, self.lookup('xs')), splice(1, self.lookup('ys'))]))]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        158,
        PUSH_SCOPE,
        CALL,
        163,
        BIND,
        'x',
        CALL,
        1035,
        MATCH,
        ':',
        lambda x: x == ':',
        CALL,
        929,
        BIND,
        'y',
        ACTION,
        lambda self: concat([splice(0, 'Bind'), splice(0, self.lookup('y')), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        162,
        PUSH_SCOPE,
        CALL,
        163,
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        180,
        PUSH_SCOPE,
        CALL,
        232,
        BIND,
        'x',
        CALL,
        1035,
        MATCH,
        '*',
        lambda x: x == '*',
        ACTION,
        lambda self: concat([splice(0, 'Star'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        231,
        BACKTRACK,
        197,
        PUSH_SCOPE,
        CALL,
        232,
        BIND,
        'x',
        CALL,
        1035,
        MATCH,
        '?',
        lambda x: x == '?',
        ACTION,
        lambda self: concat([splice(0, 'Or'), splice(0, self.lookup('x')), splice(0, concat([splice(0, 'And')]))]),
        POP_SCOPE,
        COMMIT,
        231,
        BACKTRACK,
        214,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '!',
        lambda x: x == '!',
        CALL,
        232,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, 'Not'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        231,
        BACKTRACK,
        227,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '%',
        lambda x: x == '%',
        ACTION,
        lambda self: concat([splice(0, 'MatchCallRule')]),
        POP_SCOPE,
        COMMIT,
        231,
        PUSH_SCOPE,
        CALL,
        232,
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        257,
        PUSH_SCOPE,
        CALL,
        929,
        BIND,
        'x',
        BACKTRACK,
        252,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '=',
        lambda x: x == '=',
        POP_SCOPE,
        COMMIT,
        250,
        FAIL,
        'no match',
        ACTION,
        lambda self: concat([splice(0, 'MatchRule'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        438,
        BACKTRACK,
        278,
        PUSH_SCOPE,
        CALL,
        1035,
        CALL,
        847,
        BIND,
        'x',
        MATCH,
        '-',
        lambda x: x == '-',
        CALL,
        847,
        BIND,
        'y',
        ACTION,
        lambda self: concat([splice(0, 'MatchObject'), splice(0, concat([splice(0, 'Range'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]))]),
        POP_SCOPE,
        COMMIT,
        438,
        BACKTRACK,
        316,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        "'",
        lambda x: x == "'",
        LIST_START,
        BACKTRACK,
        305,
        PUSH_SCOPE,
        BACKTRACK,
        299,
        MATCH,
        "'",
        lambda x: x == "'",
        COMMIT,
        297,
        FAIL,
        'no match',
        CALL,
        439,
        POP_SCOPE,
        LIST_APPEND,
        COMMIT,
        287,
        LIST_END,
        BIND,
        'xs',
        MATCH,
        "'",
        lambda x: x == "'",
        ACTION,
        lambda self: concat([splice(0, 'And'), splice(1, self.lookup('xs'))]),
        POP_SCOPE,
        COMMIT,
        438,
        BACKTRACK,
        329,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '.',
        lambda x: x == '.',
        ACTION,
        lambda self: concat([splice(0, 'MatchObject'), splice(0, concat([splice(0, 'Any')]))]),
        POP_SCOPE,
        COMMIT,
        438,
        BACKTRACK,
        360,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '0',
        lambda x: x == '0',
        MATCH,
        'x',
        lambda x: x == 'x',
        CALL,
        996,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        352,
        CALL,
        996,
        LIST_APPEND,
        COMMIT,
        345,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: concat([splice(0, 'MatchObject'), splice(0, concat([splice(0, 'Eq'), splice(0, self.lookup('int')(join([self.lookup('x'), self.lookup('xs')]), 16))]))]),
        POP_SCOPE,
        COMMIT,
        438,
        BACKTRACK,
        391,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '0',
        lambda x: x == '0',
        MATCH,
        'b',
        lambda x: x == 'b',
        CALL,
        1011,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        383,
        CALL,
        1011,
        LIST_APPEND,
        COMMIT,
        376,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: concat([splice(0, 'MatchBinary'), splice(0, self.lookup('compilebin')(concat([splice(0, self.lookup('x')), splice(1, self.lookup('xs'))])))]),
        POP_SCOPE,
        COMMIT,
        438,
        BACKTRACK,
        413,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '(',
        lambda x: x == '(',
        CALL,
        79,
        BIND,
        'x',
        CALL,
        1035,
        MATCH,
        ')',
        lambda x: x == ')',
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        COMMIT,
        438,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '[',
        lambda x: x == '[',
        LIST_START,
        BACKTRACK,
        427,
        CALL,
        137,
        LIST_APPEND,
        COMMIT,
        420,
        LIST_END,
        BIND,
        'xs',
        CALL,
        1035,
        MATCH,
        ']',
        lambda x: x == ']',
        ACTION,
        lambda self: concat([splice(0, 'MatchList'), splice(0, concat([splice(0, 'And'), splice(1, self.lookup('xs'))]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        871,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, 'MatchObject'), splice(0, concat([splice(0, 'Eq'), splice(0, self.lookup('x'))]))]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        460,
        PUSH_SCOPE,
        CALL,
        465,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'Action'), splice(0, self.lookup('x'))]))]),
        POP_SCOPE,
        COMMIT,
        464,
        PUSH_SCOPE,
        ACTION,
        lambda self: concat([]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        508,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '-',
        lambda x: x == '-',
        MATCH,
        '>',
        lambda x: x == '>',
        CALL,
        525,
        BIND,
        'x',
        BACKTRACK,
        493,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        ':',
        lambda x: x == ':',
        CALL,
        929,
        POP_SCOPE,
        COMMIT,
        497,
        PUSH_SCOPE,
        ACTION,
        lambda self: '',
        POP_SCOPE,
        BIND,
        'y',
        CALL,
        465,
        BIND,
        'z',
        ACTION,
        lambda self: concat([splice(0, 'Set'), splice(0, self.lookup('y')), splice(0, self.lookup('x')), splice(0, self.lookup('z'))]),
        POP_SCOPE,
        COMMIT,
        524,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '-',
        lambda x: x == '-',
        MATCH,
        '>',
        lambda x: x == '>',
        CALL,
        525,
        BIND,
        'x',
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        539,
        PUSH_SCOPE,
        CALL,
        1035,
        CALL,
        814,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, 'String'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        709,
        BACKTRACK,
        564,
        PUSH_SCOPE,
        CALL,
        1035,
        CALL,
        990,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        556,
        CALL,
        990,
        LIST_APPEND,
        COMMIT,
        549,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: concat([splice(0, 'Integer'), splice(0, self.lookup('int')(join([self.lookup('x'), self.lookup('xs')])))]),
        POP_SCOPE,
        COMMIT,
        709,
        BACKTRACK,
        593,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '[',
        lambda x: x == '[',
        LIST_START,
        BACKTRACK,
        580,
        CALL,
        757,
        LIST_APPEND,
        COMMIT,
        573,
        LIST_END,
        BIND,
        'xs',
        CALL,
        1035,
        MATCH,
        ']',
        lambda x: x == ']',
        ACTION,
        lambda self: concat([splice(0, 'List'), splice(1, self.lookup('xs'))]),
        POP_SCOPE,
        COMMIT,
        709,
        BACKTRACK,
        622,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '{',
        lambda x: x == '{',
        LIST_START,
        BACKTRACK,
        609,
        CALL,
        780,
        LIST_APPEND,
        COMMIT,
        602,
        LIST_END,
        BIND,
        'xs',
        CALL,
        1035,
        MATCH,
        '}',
        lambda x: x == '}',
        ACTION,
        lambda self: concat([splice(0, 'Format'), splice(1, self.lookup('xs'))]),
        POP_SCOPE,
        COMMIT,
        709,
        BACKTRACK,
        655,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '(',
        lambda x: x == '(',
        CALL,
        710,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        642,
        CALL,
        525,
        LIST_APPEND,
        COMMIT,
        635,
        LIST_END,
        BIND,
        'ys',
        CALL,
        1035,
        MATCH,
        ')',
        lambda x: x == ')',
        ACTION,
        lambda self: concat([splice(0, 'Op'), splice(0, self.lookup('x')), splice(1, self.lookup('ys'))]),
        POP_SCOPE,
        COMMIT,
        709,
        BACKTRACK,
        688,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '(',
        lambda x: x == '(',
        CALL,
        929,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        675,
        CALL,
        525,
        LIST_APPEND,
        COMMIT,
        668,
        LIST_END,
        BIND,
        'ys',
        CALL,
        1035,
        MATCH,
        ')',
        lambda x: x == ')',
        ACTION,
        lambda self: concat([splice(0, 'Call'), splice(0, concat([splice(0, 'Lookup'), splice(0, self.lookup('x'))])), splice(1, self.lookup('ys'))]),
        POP_SCOPE,
        COMMIT,
        709,
        PUSH_SCOPE,
        CALL,
        929,
        BIND,
        'x',
        BACKTRACK,
        706,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '=',
        lambda x: x == '=',
        POP_SCOPE,
        COMMIT,
        704,
        FAIL,
        'no match',
        ACTION,
        lambda self: concat([splice(0, 'Lookup'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        719,
        PUSH_SCOPE,
        MATCH,
        '+',
        lambda x: x == '+',
        POP_SCOPE,
        COMMIT,
        756,
        BACKTRACK,
        728,
        PUSH_SCOPE,
        MATCH,
        '-',
        lambda x: x == '-',
        POP_SCOPE,
        COMMIT,
        756,
        BACKTRACK,
        737,
        PUSH_SCOPE,
        MATCH,
        '*',
        lambda x: x == '*',
        POP_SCOPE,
        COMMIT,
        756,
        BACKTRACK,
        746,
        PUSH_SCOPE,
        MATCH,
        '%',
        lambda x: x == '%',
        POP_SCOPE,
        COMMIT,
        756,
        PUSH_SCOPE,
        MATCH,
        '<',
        lambda x: x == '<',
        MATCH,
        '<',
        lambda x: x == '<',
        ACTION,
        lambda self: '<<',
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        1035,
        LIST_START,
        BACKTRACK,
        769,
        MATCH,
        '~',
        lambda x: x == '~',
        LIST_APPEND,
        COMMIT,
        761,
        LIST_END,
        BIND,
        'ys',
        CALL,
        525,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, 'ListItem'), splice(0, self.lookup('len')(self.lookup('ys'))), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        809,
        PUSH_SCOPE,
        CALL,
        1035,
        MATCH,
        '>',
        lambda x: x == '>',
        LIST_START,
        BACKTRACK,
        796,
        CALL,
        780,
        LIST_APPEND,
        COMMIT,
        789,
        LIST_END,
        BIND,
        'xs',
        CALL,
        1035,
        MATCH,
        '<',
        lambda x: x == '<',
        ACTION,
        lambda self: concat([splice(0, 'Indent'), splice(0, concat([splice(0, 'Format'), splice(1, self.lookup('xs'))]))]),
        POP_SCOPE,
        COMMIT,
        813,
        PUSH_SCOPE,
        CALL,
        525,
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        '"',
        lambda x: x == '"',
        LIST_START,
        BACKTRACK,
        837,
        PUSH_SCOPE,
        BACKTRACK,
        831,
        MATCH,
        '"',
        lambda x: x == '"',
        COMMIT,
        829,
        FAIL,
        'no match',
        CALL,
        871,
        POP_SCOPE,
        LIST_APPEND,
        COMMIT,
        819,
        LIST_END,
        BIND,
        'xs',
        MATCH,
        '"',
        lambda x: x == '"',
        ACTION,
        lambda self: join([self.lookup('xs')]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        "'",
        lambda x: x == "'",
        BACKTRACK,
        860,
        MATCH,
        "'",
        lambda x: x == "'",
        COMMIT,
        858,
        FAIL,
        'no match',
        CALL,
        871,
        BIND,
        'x',
        MATCH,
        "'",
        lambda x: x == "'",
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        882,
        PUSH_SCOPE,
        MATCH,
        '\\',
        lambda x: x == '\\',
        CALL,
        888,
        POP_SCOPE,
        COMMIT,
        887,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        899,
        PUSH_SCOPE,
        MATCH,
        '\\',
        lambda x: x == '\\',
        ACTION,
        lambda self: '\\',
        POP_SCOPE,
        COMMIT,
        928,
        BACKTRACK,
        910,
        PUSH_SCOPE,
        MATCH,
        "'",
        lambda x: x == "'",
        ACTION,
        lambda self: "'",
        POP_SCOPE,
        COMMIT,
        928,
        BACKTRACK,
        921,
        PUSH_SCOPE,
        MATCH,
        '"',
        lambda x: x == '"',
        ACTION,
        lambda self: '"',
        POP_SCOPE,
        COMMIT,
        928,
        PUSH_SCOPE,
        MATCH,
        'n',
        lambda x: x == 'n',
        ACTION,
        lambda self: '\n',
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        1035,
        CALL,
        951,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        944,
        CALL,
        966,
        LIST_APPEND,
        COMMIT,
        937,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: join([self.lookup('x'), self.lookup('xs')]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        960,
        PUSH_SCOPE,
        MATCH,
        "range 'a'-'z'",
        lambda x: 'a' <= x <= 'z',
        POP_SCOPE,
        COMMIT,
        965,
        PUSH_SCOPE,
        MATCH,
        "range 'A'-'Z'",
        lambda x: 'A' <= x <= 'Z',
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        975,
        PUSH_SCOPE,
        MATCH,
        "range 'a'-'z'",
        lambda x: 'a' <= x <= 'z',
        POP_SCOPE,
        COMMIT,
        989,
        BACKTRACK,
        984,
        PUSH_SCOPE,
        MATCH,
        "range 'A'-'Z'",
        lambda x: 'A' <= x <= 'Z',
        POP_SCOPE,
        COMMIT,
        989,
        PUSH_SCOPE,
        MATCH,
        "range '0'-'9'",
        lambda x: '0' <= x <= '9',
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        "range '0'-'9'",
        lambda x: '0' <= x <= '9',
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        1005,
        PUSH_SCOPE,
        MATCH,
        "range '0'-'9'",
        lambda x: '0' <= x <= '9',
        POP_SCOPE,
        COMMIT,
        1010,
        PUSH_SCOPE,
        MATCH,
        "range 'A'-'F'",
        lambda x: 'A' <= x <= 'F',
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        1020,
        PUSH_SCOPE,
        MATCH,
        '0',
        lambda x: x == '0',
        POP_SCOPE,
        COMMIT,
        1034,
        BACKTRACK,
        1029,
        PUSH_SCOPE,
        MATCH,
        '1',
        lambda x: x == '1',
        POP_SCOPE,
        COMMIT,
        1034,
        PUSH_SCOPE,
        MATCH,
        "range 'a'-'z'",
        lambda x: 'a' <= x <= 'z',
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        1056,
        BACKTRACK,
        1048,
        PUSH_SCOPE,
        MATCH,
        ' ',
        lambda x: x == ' ',
        POP_SCOPE,
        COMMIT,
        1053,
        PUSH_SCOPE,
        MATCH,
        '\n',
        lambda x: x == '\n',
        POP_SCOPE,
        LIST_APPEND,
        COMMIT,
        1037,
        LIST_END,
        POP_SCOPE,
        RETURN
    ]
class CodeGenerator(Grammar):
    rules = {
        'Grammar': 0,
        'Rule': 21,
        'Or': 35,
        'Scope': 56,
        'And': 65,
        'Bind': 81,
        'Star': 95,
        'Not': 104,
        'MatchCallRule': 113,
        'MatchRule': 118,
        'MatchObject': 128,
        'MatchBinary': 138,
        'MatchList': 148,
        'Action': 157,
        'asts': 167,
        'ast': 192
    }
    code = [
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        14,
        CALL,
        192,
        LIST_APPEND,
        COMMIT,
        7,
        LIST_END,
        BIND,
        'ys',
        ACTION,
        lambda self: concat([splice(0, 'Grammar'), splice(0, self.lookup('x')), splice(2, self.lookup('ys'))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        192,
        BIND,
        'y',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'Rule'), splice(0, self.lookup('x'))])), splice(1, self.lookup('y')), splice(0, concat([splice(0, 'OpCode'), splice(0, 'RETURN')]))]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        51,
        PUSH_SCOPE,
        CALL,
        192,
        BIND,
        'x',
        CALL,
        35,
        BIND,
        'y',
        ACTION,
        lambda self: self.bind('a', self.lookup('label')(), lambda: self.bind('b', self.lookup('label')(), lambda: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'BACKTRACK')])), splice(0, concat([splice(0, 'Target'), splice(0, self.lookup('a'))])), splice(1, self.lookup('x')), splice(0, concat([splice(0, 'OpCode'), splice(0, 'COMMIT')])), splice(0, concat([splice(0, 'Target'), splice(0, self.lookup('b'))])), splice(0, concat([splice(0, 'Label'), splice(0, self.lookup('a'))])), splice(1, self.lookup('y')), splice(0, concat([splice(0, 'Label'), splice(0, self.lookup('b'))]))]))),
        POP_SCOPE,
        COMMIT,
        55,
        PUSH_SCOPE,
        CALL,
        192,
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        192,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'PUSH_SCOPE')])), splice(1, self.lookup('x')), splice(0, concat([splice(0, 'OpCode'), splice(0, 'POP_SCOPE')]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        74,
        CALL,
        192,
        LIST_APPEND,
        COMMIT,
        67,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: concat([splice(2, self.lookup('xs'))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        192,
        BIND,
        'y',
        ACTION,
        lambda self: concat([splice(1, self.lookup('y')), splice(0, concat([splice(0, 'OpCode'), splice(0, 'BIND')])), splice(0, concat([splice(0, 'Value'), splice(0, self.lookup('x'))]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        192,
        BIND,
        'x',
        ACTION,
        lambda self: self.bind('a', self.lookup('label')(), lambda: self.bind('b', self.lookup('label')(), lambda: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'LIST_START')])), splice(0, concat([splice(0, 'Label'), splice(0, self.lookup('a'))])), splice(0, concat([splice(0, 'OpCode'), splice(0, 'BACKTRACK')])), splice(0, concat([splice(0, 'Target'), splice(0, self.lookup('b'))])), splice(1, self.lookup('x')), splice(0, concat([splice(0, 'OpCode'), splice(0, 'LIST_APPEND')])), splice(0, concat([splice(0, 'OpCode'), splice(0, 'COMMIT')])), splice(0, concat([splice(0, 'Target'), splice(0, self.lookup('a'))])), splice(0, concat([splice(0, 'Label'), splice(0, self.lookup('b'))])), splice(0, concat([splice(0, 'OpCode'), splice(0, 'LIST_END')]))]))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        192,
        BIND,
        'x',
        ACTION,
        lambda self: self.bind('a', self.lookup('label')(), lambda: self.bind('b', self.lookup('label')(), lambda: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'BACKTRACK')])), splice(0, concat([splice(0, 'Target'), splice(0, self.lookup('b'))])), splice(1, self.lookup('x')), splice(0, concat([splice(0, 'OpCode'), splice(0, 'COMMIT')])), splice(0, concat([splice(0, 'Target'), splice(0, self.lookup('a'))])), splice(0, concat([splice(0, 'Label'), splice(0, self.lookup('a'))])), splice(0, concat([splice(0, 'OpCode'), splice(0, 'FAIL')])), splice(0, concat([splice(0, 'Value'), splice(0, 'no match')])), splice(0, concat([splice(0, 'Label'), splice(0, self.lookup('b'))]))]))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'MATCH_CALL_RULE')]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'CALL')])), splice(0, concat([splice(0, 'Target'), splice(0, self.lookup('x'))]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'MATCH')])), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'MATCH_BINARY')])), splice(0, concat([splice(0, 'Value'), splice(0, self.lookup('x'))]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        192,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'PUSH_STREAM')])), splice(1, self.lookup('x')), splice(0, concat([splice(0, 'OpCode'), splice(0, 'POP_STREAM')]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, concat([splice(0, 'OpCode'), splice(0, 'ACTION')])), splice(0, concat([splice(0, 'Action'), splice(0, self.lookup('x'))]))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        176,
        CALL,
        192,
        LIST_APPEND,
        COMMIT,
        169,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        188,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        186,
        FAIL,
        'no match',
        ACTION,
        lambda self: self.lookup('xs'),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH_CALL_RULE,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        RETURN
    ]
class Assembler(Grammar):
    rules = {
        'Grammar': 0,
        'Rule': 21,
        'Label': 31,
        'Target': 41,
        'Patch': 51,
        'OpCode': 66,
        'Value': 76,
        'Eq': 86,
        'Range': 96,
        'Any': 111,
        'Action': 116,
        'Set': 125,
        'String': 143,
        'Integer': 153,
        'List': 163,
        'ListItem': 172,
        'Format': 186,
        'Indent': 195,
        'Call': 204,
        'Op': 217,
        'Lookup': 238,
        'asts': 248,
        'astList': 273,
        'ast': 289
    }
    code = [
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        14,
        CALL,
        289,
        LIST_APPEND,
        COMMIT,
        7,
        LIST_END,
        BIND,
        'ys',
        ACTION,
        lambda self: self.bind('rules', self.lookup('list')(), lambda: self.bind('code', self.lookup('list')(), lambda: self.bind('labels', self.lookup('dict')(), lambda: self.bind('patches', self.lookup('list')(), lambda: self.bind('', self.lookup('ys'), lambda: self.bind('', self.lookup('run')('asts', self.lookup('patches')), lambda: join(['class ', self.lookup('x'), '(Grammar):\n', indent(join(['rules = {\n', indent(join([self.lookup('join')(self.lookup('rules'), ',\n')]), self.lookup('indentprefix')), '\n}\n', 'code = [\n', indent(join([self.lookup('join')(self.lookup('code'), ',\n')]), self.lookup('indentprefix')), '\n]\n']), self.lookup('indentprefix'))]))))))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.bind('', self.lookup('add')(self.lookup('rules'), join([self.lookup('repr')(self.lookup('x')), ': ', self.lookup('len')(self.lookup('code'))])), lambda: self.lookup('set')(self.lookup('labels'), self.lookup('x'), self.lookup('len')(self.lookup('code')))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.lookup('set')(self.lookup('labels'), self.lookup('x'), self.lookup('len')(self.lookup('code'))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.bind('', self.lookup('add')(self.lookup('patches'), concat([splice(0, 'Patch'), splice(0, self.lookup('len')(self.lookup('code'))), splice(0, self.lookup('x'))])), lambda: self.lookup('add')(self.lookup('code'), 'placeholder')),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'y',
        ACTION,
        lambda self: self.lookup('set')(self.lookup('code'), self.lookup('x'), self.lookup('get')(self.lookup('labels'), self.lookup('y'))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.lookup('add')(self.lookup('code'), self.lookup('x')),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.lookup('add')(self.lookup('code'), self.lookup('repr')(self.lookup('x'))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.bind('', self.lookup('add')(self.lookup('code'), self.lookup('repr')(self.lookup('x'))), lambda: self.lookup('add')(self.lookup('code'), join(['lambda x: x == ', self.lookup('repr')(self.lookup('x'))]))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'y',
        ACTION,
        lambda self: self.bind('', self.lookup('add')(self.lookup('code'), self.lookup('repr')(join(['range ', self.lookup('repr')(self.lookup('x')), '-', self.lookup('repr')(self.lookup('y'))]))), lambda: self.lookup('add')(self.lookup('code'), join(['lambda x: ', self.lookup('repr')(self.lookup('x')), ' <= x <= ', self.lookup('repr')(self.lookup('y'))]))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        ACTION,
        lambda self: self.bind('', self.lookup('add')(self.lookup('code'), self.lookup('repr')('any')), lambda: self.lookup('add')(self.lookup('code'), 'lambda x: True')),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        289,
        BIND,
        'x',
        ACTION,
        lambda self: self.lookup('add')(self.lookup('code'), join(['lambda self: ', self.lookup('x')])),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        289,
        BIND,
        'y',
        CALL,
        289,
        BIND,
        'z',
        ACTION,
        lambda self: join(['self.bind(', self.lookup('repr')(self.lookup('x')), ', ', self.lookup('y'), ', lambda: ', self.lookup('z'), ')']),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.lookup('repr')(self.lookup('x')),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: self.lookup('repr')(self.lookup('x')),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        273,
        BIND,
        'x',
        ACTION,
        lambda self: join(['concat([', self.lookup('x'), '])']),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        289,
        BIND,
        'y',
        ACTION,
        lambda self: join(['splice(', self.lookup('repr')(self.lookup('x')), ', ', self.lookup('y'), ')']),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        273,
        BIND,
        'x',
        ACTION,
        lambda self: join(['join([', self.lookup('x'), '])']),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        289,
        BIND,
        'x',
        ACTION,
        lambda self: join(['indent(', self.lookup('x'), ', ', "self.lookup('indentprefix'))"]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        CALL,
        289,
        BIND,
        'x',
        CALL,
        273,
        BIND,
        'y',
        ACTION,
        lambda self: join([self.lookup('x'), '(', self.lookup('y'), ')']),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        LIST_START,
        BACKTRACK,
        231,
        CALL,
        289,
        LIST_APPEND,
        COMMIT,
        224,
        LIST_END,
        BIND,
        'ys',
        ACTION,
        lambda self: join(['(', self.lookup('join')(self.lookup('ys'), self.lookup('x')), ')']),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        ACTION,
        lambda self: join(['self.lookup(', self.lookup('repr')(self.lookup('x')), ')']),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        257,
        CALL,
        289,
        LIST_APPEND,
        COMMIT,
        250,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        269,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        267,
        FAIL,
        'no match',
        ACTION,
        lambda self: join([self.lookup('xs')]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        282,
        CALL,
        289,
        LIST_APPEND,
        COMMIT,
        275,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: self.lookup('join')(self.lookup('xs'), ', '),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH_CALL_RULE,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        RETURN
    ]
if __name__ == "__main__":
    import sys
    def read(path):
        if path == "-":
            return sys.stdin.read()
        with open(path) as f:
            return f.read()
    args = sys.argv[1:] or ["--compile", "-"]
    while args:
        command = args.pop(0)
        if command == "--support":
            sys.stdout.write(SUPPORT)
        elif command == "--copy":
            sys.stdout.write(read(args.pop(0)))
        elif command == "--embed":
            sys.stdout.write("{} = {}\n".format(
                args.pop(0),
                repr(read(args.pop(0)))
            ))
        elif command == "--compile":
            sys.stdout.write(compile_chain(
                [(Parser, "file"), (CodeGenerator, "asts"), (Assembler, "asts")],
                read(args.pop(0))
            ))
        else:
            sys.exit("ERROR: Unknown command '{}'".format(command))
